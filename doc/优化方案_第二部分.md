# Joy IP 3D 项目优化方案（第二部分）

## 三、错误处理不一致问题

### 3.1 问题描述

当前API错误处理存在以下问题：
- 部分API返回500状态码，部分返回200+error字段
- 异常处理风格不统一（有的打印日志，有的静默失败）
- 缺乏统一的错误响应格式

### 3.2 优化方案

#### 步骤1：创建统一的错误响应工具模块

创建 `utils/response.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
统一API响应格式工具
"""

from flask import jsonify
from typing import Any, Dict, Optional
import logging

logger = logging.getLogger(__name__)


class APIResponse:
    """统一API响应格式"""
    
    @staticmethod
    def success(
        data: Any = None,
        message: str = "操作成功",
        **kwargs
    ) -> tuple:
        """
        成功响应
        
        Args:
            data: 返回数据
            message: 成功消息
            **kwargs: 额外字段
        
        Returns:
            tuple: (response, status_code)
        """
        response = {
            "success": True,
            "message": message,
            "data": data,
            **kwargs
        }
        return jsonify(response), 200
    
    @staticmethod
    def error(
        message: str,
        code: str = "ERROR",
        status_code: int = 200,
        details: Optional[Dict] = None,
        **kwargs
    ) -> tuple:
        """
        错误响应（业务错误，返回200）
        
        Args:
            message: 错误消息
            code: 错误代码（用于前端判断）
            status_code: HTTP状态码（默认200，业务错误不应返回500）
            details: 错误详情
            **kwargs: 额外字段
        
        Returns:
            tuple: (response, status_code)
        """
        response = {
            "success": False,
            "error": message,
            "code": code,
            **kwargs
        }
        if details:
            response["details"] = details
        return jsonify(response), status_code
    
    @staticmethod
    def server_error(
        message: str = "服务器内部错误",
        exception: Optional[Exception] = None
    ) -> tuple:
        """
        服务器错误响应（返回500）
        
        Args:
            message: 错误消息
            exception: 异常对象（用于日志记录）
        
        Returns:
            tuple: (response, status_code)
        """
        if exception:
            logger.error(f"{message}: {str(exception)}", exc_info=True)
        
        response = {
            "success": False,
            "error": message,
            "code": "SERVER_ERROR"
        }
        return jsonify(response), 500


# 错误代码常量
class ErrorCode:
    """错误代码常量"""
    # 参数错误
    MISSING_PARAM = "MISSING_PARAM"
    INVALID_PARAM = "INVALID_PARAM"
    
    # 业务错误
    COMPLIANCE_ERROR = "COMPLIANCE"
    GENERATION_FAILED = "GENERATION_FAILED"
    FILE_NOT_FOUND = "FILE_NOT_FOUND"
    UPLOAD_FAILED = "UPLOAD_FAILED"
    SCRIPT_ERROR = "SCRIPT_ERROR"
    
    # 任务错误
    JOB_NOT_FOUND = "JOB_NOT_FOUND"
    JOB_FAILED = "JOB_FAILED"
    
    # 服务器错误
    SERVER_ERROR = "SERVER_ERROR"
```

#### 步骤2：统一API错误处理示例

修改前（不一致的错误处理）：

```python
# 示例1：返回500
@app.route('/api/generate', methods=['POST'])
def generate():
    try:
        # ...
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# 示例2：返回200+error
@app.route('/api/run-banana', methods=['POST'])
def run_banana():
    if not tag_img_url:
        return jsonify({'success': False, 'error': '缺少参数'}), 200
```

修改后（统一格式）：

```python
from utils.response import APIResponse, ErrorCode

@app.route('/api/generate', methods=['POST'])
def generate():
    try:
        data = request.get_json()
        requirement = data.get('requirement', '')
        
        if not requirement:
            return APIResponse.error(
                message="请输入需求描述",
                code=ErrorCode.MISSING_PARAM
            )
        
        # 业务逻辑...
        
        if not result['success']:
            return APIResponse.error(
                message=result.get('error', '生成失败'),
                code=ErrorCode.GENERATION_FAILED,
                details=result.get('details')
            )
        
        return APIResponse.success(
            data={'images': image_urls},
            message="生成成功",
            total=len(image_urls)
        )
        
    except Exception as e:
        return APIResponse.server_error(
            message="生成过程发生错误",
            exception=e
        )
```

#### 步骤3：创建全局异常处理器

在 `app_new.py` 中添加：

```python
from werkzeug.exceptions import HTTPException

@app.errorhandler(Exception)
def handle_exception(e):
    """全局异常处理器"""
    # HTTP异常（如404、405等）
    if isinstance(e, HTTPException):
        return APIResponse.error(
            message=e.description,
            code=f"HTTP_{e.code}",
            status_code=e.code
        )
    
    # 其他未捕获的异常
    logger.error(f"未捕获的异常: {str(e)}", exc_info=True)
    return APIResponse.server_error(
        message="服务器内部错误",
        exception=e
    )
```

---

## 四、日志系统混乱问题

### 4.1 问题描述

- 混用 `print()` 和 `logger.info()`
- 部分模块没有配置logger
- 日志格式不统一

### 4.2 优化方案

#### 步骤1：创建统一的日志配置模块

创建 `utils/logger.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
统一日志配置模块
"""

import os
import logging
import sys
from logging.handlers import RotatingFileHandler
from typing import Optional


def setup_logger(
    name: str = None,
    level: str = "INFO",
    log_file: Optional[str] = None,
    max_bytes: int = 10 * 1024 * 1024,  # 10MB
    backup_count: int = 5
) -> logging.Logger:
    """
    配置并返回logger实例
    
    Args:
        name: logger名称，None表示root logger
        level: 日志级别
        log_file: 日志文件路径
        max_bytes: 单个日志文件最大大小
        backup_count: 保留的日志文件数量
    
    Returns:
        logging.Logger: 配置好的logger实例
    """
    logger = logging.getLogger(name)
    
    # 避免重复配置
    if logger.handlers:
        return logger
    
    logger.setLevel(getattr(logging, level.upper(), logging.INFO))
    
    # 统一日志格式
    formatter = logging.Formatter(
        fmt='%(asctime)s | %(levelname)-8s | %(name)s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # 控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # 文件处理器（如果指定了日志文件）
    if log_file:
        log_dir = os.path.dirname(log_file)
        if log_dir:
            os.makedirs(log_dir, exist_ok=True)
        
        file_handler = RotatingFileHandler(
            log_file,
            maxBytes=max_bytes,
            backupCount=backup_count,
            encoding='utf-8'
        )
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    
    return logger


def get_logger(name: str) -> logging.Logger:
    """
    获取指定名称的logger
    
    Args:
        name: logger名称（通常使用 __name__）
    
    Returns:
        logging.Logger: logger实例
    """
    return logging.getLogger(name)


# 初始化根logger
def init_app_logger():
    """初始化应用级别的logger"""
    from config import get_config
    config = get_config()
    
    log_level = os.environ.get('LOG_LEVEL', 'INFO')
    log_file = os.environ.get('LOG_FILE')
    
    setup_logger(
        name=None,  # root logger
        level=log_level,
        log_file=log_file
    )
```

#### 步骤2：各模块使用统一的logger

修改前：

```python
# content_agent.py
print(f"AI敏感内容检查HTTP错误: {e}")

# generation_controller.py
print(f"✓ 成功处理服装: {result_path}")
```

修改后：

```python
# content_agent.py
from utils.logger import get_logger
logger = get_logger(__name__)

logger.error(f"AI敏感内容检查HTTP错误: {e}")

# generation_controller.py
from utils.logger import get_logger
logger = get_logger(__name__)

logger.info(f"成功处理服装: {result_path}")
```

#### 步骤3：日志级别使用规范

| 级别 | 使用场景 |
|------|----------|
| DEBUG | 调试信息，生产环境不输出 |
| INFO | 正常业务流程信息 |
| WARNING | 警告信息，不影响主流程 |
| ERROR | 错误信息，需要关注 |
| CRITICAL | 严重错误，系统可能无法继续运行 |

示例：

```python
logger.debug(f"请求参数: {data}")
logger.info(f"开始处理用户需求: {requirement}")
logger.warning(f"图片上传失败，使用本地路径: {local_path}")
logger.error(f"生成图片失败: {str(e)}", exc_info=True)
```

---

## 五、模块加载方式问题

### 5.1 问题描述

使用 `importlib.util` 动态加载带连字符的Python文件（如 `banana-clothes.py`），存在以下问题：
- 代码冗长，每个模块都需要重复加载逻辑
- 不符合Python命名规范
- 难以维护和调试

### 5.2 优化方案

#### 方案A：重命名文件（推荐）

将所有带连字符的文件重命名为下划线格式：

```
banana-clothes.py  →  banana_clothes.py
banana-hands.py    →  banana_hands.py
banana-hats.py     →  banana_hats.py
banana-background.py → banana_background.py
gate-result.py     →  gate_result.py
per-data.py        →  per_data.py
3D-banana-all.py   →  banana_3d_all.py
```

然后使用标准导入：

```python
# 修改前
spec = importlib.util.spec_from_file_location("banana_clothes", "banana-clothes.py")
# ...复杂的加载逻辑

# 修改后
from banana_clothes import generate_image_with_accessories
```

#### 方案B：创建统一的模块加载器

如果不想重命名文件，创建 `utils/module_loader.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
统一模块加载器
用于加载不符合Python命名规范的模块文件
"""

import os
import sys
import importlib.util
from typing import Optional, Any
import logging

logger = logging.getLogger(__name__)


class ModuleLoader:
    """模块加载器"""
    
    _cache = {}  # 模块缓存
    
    @classmethod
    def load(
        cls,
        file_name: str,
        module_name: Optional[str] = None,
        base_dir: Optional[str] = None
    ) -> Optional[Any]:
        """
        加载Python模块文件
        
        Args:
            file_name: 文件名（如 'banana-clothes.py'）
            module_name: 模块名（默认从文件名生成）
            base_dir: 基础目录（默认为当前文件所在目录）
        
        Returns:
            加载的模块对象，失败返回None
        """
        if base_dir is None:
            base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        
        if module_name is None:
            # 将文件名转换为有效的模块名
            module_name = file_name.replace('.py', '').replace('-', '_')
        
        # 检查缓存
        cache_key = f"{base_dir}/{file_name}"
        if cache_key in cls._cache:
            return cls._cache[cache_key]
        
        module_path = os.path.join(base_dir, file_name)
        
        if not os.path.exists(module_path):
            logger.warning(f"模块文件不存在: {module_path}")
            return None
        
        try:
            spec = importlib.util.spec_from_file_location(module_name, module_path)
            if spec is None or spec.loader is None:
                logger.error(f"无法创建模块规范: {module_path}")
                return None
            
            module = importlib.util.module_from_spec(spec)
            sys.modules[module_name] = module
            spec.loader.exec_module(module)
            
            # 缓存模块
            cls._cache[cache_key] = module
            logger.debug(f"成功加载模块: {file_name} -> {module_name}")
            
            return module
            
        except Exception as e:
            logger.error(f"加载模块失败 {file_name}: {str(e)}")
            return None
    
    @classmethod
    def get_function(
        cls,
        file_name: str,
        function_name: str,
        base_dir: Optional[str] = None
    ) -> Optional[callable]:
        """
        从模块中获取指定函数
        
        Args:
            file_name: 文件名
            function_name: 函数名
            base_dir: 基础目录
        
        Returns:
            函数对象，失败返回None
        """
        module = cls.load(file_name, base_dir=base_dir)
        if module is None:
            return None
        
        func = getattr(module, function_name, None)
        if func is None:
            logger.warning(f"模块 {file_name} 中未找到函数 {function_name}")
        
        return func
```

使用示例：

```python
from utils.module_loader import ModuleLoader

# 加载模块
banana_clothes = ModuleLoader.load('banana-clothes.py')
if banana_clothes:
    result = banana_clothes.generate_image_with_accessories(image_path, info)

# 或直接获取函数
generate_func = ModuleLoader.get_function('banana-clothes.py', 'generate_image_with_accessories')
if generate_func:
    result = generate_func(image_path, info)
```

---

## 六、线程安全问题

### 6.1 问题描述

- `_run_generation_job` 中每次都创建新的 matcher 实例，浪费资源
- 使用简单的内存字典存储任务状态，不适合生产环境
- 没有任务超时和清理机制

### 6.2 优化方案

#### 步骤1：使用单例模式管理共享资源

创建 `utils/singleton.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
单例模式工具
"""

import threading
from typing import TypeVar, Type

T = TypeVar('T')


class Singleton:
    """线程安全的单例基类"""
    
    _instances = {}
    _lock = threading.Lock()
    
    def __new__(cls, *args, **kwargs):
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances:
                    instance = super().__new__(cls)
                    cls._instances[cls] = instance
        return cls._instances[cls]
```

#### 步骤2：创建共享资源管理器

创建 `utils/resource_manager.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
共享资源管理器
管理全局共享的matcher、processor等实例
"""

import threading
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class ResourceManager:
    """共享资源管理器（线程安全单例）"""
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
        
        self._initialized = True
        self._resources = {}
        self._resource_lock = threading.Lock()
        
        logger.info("ResourceManager 初始化完成")
    
    def get_head_matcher(self):
        """获取头像匹配器（懒加载）"""
        return self._get_or_create('head_matcher', self._create_head_matcher)
    
    def get_body_matcher(self):
        """获取身体匹配器（懒加载）"""
        return self._get_or_create('body_matcher', self._create_body_matcher)
    
    def get_content_agent(self):
        """获取内容代理（懒加载）"""
        return self._get_or_create('content_agent', self._create_content_agent)
    
    def get_generation_controller(self):
        """获取生成控制器（懒加载）"""
        return self._get_or_create('generation_controller', self._create_generation_controller)
    
    def get_image_processor(self):
        """获取图片处理器（懒加载）"""
        return self._get_or_create('image_processor', self._create_image_processor)
    
    def _get_or_create(self, key: str, factory):
        """获取或创建资源"""
        if key not in self._resources:
            with self._resource_lock:
                if key not in self._resources:
                    logger.debug(f"创建资源: {key}")
                    self._resources[key] = factory()
        return self._resources[key]
    
    def _create_head_matcher(self):
        from matchers.head_matcher import HeadMatcher
        return HeadMatcher()
    
    def _create_body_matcher(self):
        from matchers.body_matcher import BodyMatcher
        return BodyMatcher()
    
    def _create_content_agent(self):
        from content_agent import ContentAgent
        return ContentAgent()
    
    def _create_generation_controller(self):
        from generation_controller import GenerationController
        return GenerationController()
    
    def _create_image_processor(self):
        from image_processor import ImageProcessor
        return ImageProcessor()


# 全局资源管理器实例
resources = ResourceManager()
```

#### 步骤3：改进任务队列

创建 `utils/job_manager.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
任务管理器
管理后台生成任务的生命周期
"""

import threading
import time
import uuid
from typing import Dict, Optional, List, Callable
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class JobStatus(Enum):
    """任务状态"""
    QUEUED = "queued"
    RUNNING = "running"
    SUCCEEDED = "succeeded"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class Job:
    """任务数据类"""
    job_id: str
    requirement: str
    status: JobStatus = JobStatus.QUEUED
    progress: int = 0
    stage: str = "queued"
    analysis: Optional[Dict] = None
    images: List[str] = field(default_factory=list)
    error: Optional[str] = None
    details: Dict = field(default_factory=dict)
    logs: List[str] = field(default_factory=list)
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)
    
    def to_dict(self) -> Dict:
        """转换为字典"""
        return {
            "job_id": self.job_id,
            "status": self.status.value,
            "progress": self.progress,
            "stage": self.stage,
            "analysis": self.analysis,
            "images": self.images,
            "error": self.error,
            "details": self.details,
            "updated_at": self.updated_at
        }


class JobManager:
    """任务管理器"""
    
    def __init__(
        self,
        max_jobs: int = 100,
        job_ttl: int = 3600,  # 任务保留时间（秒）
        cleanup_interval: int = 300  # 清理间隔（秒）
    ):
        self._jobs: Dict[str, Job] = {}
        self._lock = threading.Lock()
        self._max_jobs = max_jobs
        self._job_ttl = job_ttl
        
        # 启动清理线程
        self._cleanup_thread = threading.Thread(
            target=self._cleanup_loop,
            args=(cleanup_interval,),
            daemon=True
        )
        self._cleanup_thread.start()
        
        logger.info(f"JobManager 初始化完成: max_jobs={max_jobs}, ttl={job_ttl}s")
    
    def create_job(self, requirement: str) -> str:
        """创建新任务"""
        job_id = uuid.uuid4().hex
        
        with self._lock:
            # 检查任务数量限制
            if len(self._jobs) >= self._max_jobs:
                self._cleanup_old_jobs()
            
            job = Job(job_id=job_id, requirement=requirement)
            self._jobs[job_id] = job
        
        logger.info(f"创建任务: {job_id}")
        return job_id
    
    def get_job(self, job_id: str) -> Optional[Job]:
        """获取任务"""
        with self._lock:
            return self._jobs.get(job_id)
    
    def update_job(self, job_id: str, **kwargs):
        """更新任务"""
        with self._lock:
            job = self._jobs.get(job_id)
            if job:
                for key, value in kwargs.items():
                    if key == 'status' and isinstance(value, str):
                        value = JobStatus(value)
                    if hasattr(job, key):
                        setattr(job, key, value)
                job.updated_at = time.time()
    
    def append_log(self, job_id: str, message: str):
        """追加日志"""
        with self._lock:
            job = self._jobs.get(job_id)
            if job:
                seq = len(job.logs) + 1
                job.logs.append(f"步骤{seq}: {message}")
                job.updated_at = time.time()
    
    def _cleanup_old_jobs(self):
        """清理过期任务"""
        now = time.time()
        expired = [
            job_id for job_id, job in self._jobs.items()
            if now - job.created_at > self._job_ttl
            and job.status in (JobStatus.SUCCEEDED, JobStatus.FAILED, JobStatus.CANCELLED)
        ]
        
        for job_id in expired:
            del self._jobs[job_id]
        
        if expired:
            logger.info(f"清理了 {len(expired)} 个过期任务")
    
    def _cleanup_loop(self, interval: int):
        """定期清理循环"""
        while True:
            time.sleep(interval)
            with self._lock:
                self._cleanup_old_jobs()


# 全局任务管理器
job_manager = JobManager()
```

#### 步骤4：修改 `_run_generation_job` 使用共享资源

```python
from utils.resource_manager import resources
from utils.job_manager import job_manager, JobStatus

def _run_generation_job(job_id: str, requirement: str):
    """在后台线程中执行完整生成流程"""
    try:
        job_manager.update_job(job_id, status=JobStatus.RUNNING, stage='analyze', progress=5)
        job_manager.append_log(job_id, f"收到生成请求: {requirement}")

        # 使用共享资源，而不是每次创建新实例
        head_matcher = resources.get_head_matcher()
        body_matcher = resources.get_body_matcher()
        content_agent = resources.get_content_agent()
        generation_controller = resources.get_generation_controller()
        image_processor = resources.get_image_processor()

        # 后续逻辑保持不变...
        
    except Exception as e:
        logger.error(f"任务执行失败: {str(e)}", exc_info=True)
        job_manager.update_job(job_id, status=JobStatus.FAILED, error=str(e))
```

---

## 七、实施优先级

| 优先级 | 优化项 | 工作量 | 影响范围 | 建议 |
|--------|--------|--------|----------|------|
| P0 | 统一日志系统 | 3小时 | 全局 | 立即实施 |
| P1 | 统一错误响应 | 2小时 | API层 | 立即实施 |
| P2 | 模块加载器 | 1小时 | 模块加载 | 可选 |
| P2 | 共享资源管理 | 2小时 | 性能优化 | 建议实施 |
| P3 | 任务队列改进 | 3小时 | 后台任务 | 后续迭代 |

---

## 八、验证清单

- [x] 创建 `utils/response.py` 统一响应格式
- [x] 创建 `utils/logger.py` 统一日志配置
- [x] 创建 `utils/module_loader.py` 统一模块加载
- [x] 创建 `utils/resource_manager.py` 共享资源管理
- [x] 创建 `utils/job_manager.py` 任务管理器
- [x] 移除所有 `print()` 语句，替换为 `logger`
- [ ] 统一所有API的错误响应格式（需要逐个API修改）
- [ ] 添加全局异常处理器

## 九、已完成的修改

1. **utils/response.py** - 统一API响应格式工具
2. **utils/logger.py** - 统一日志配置模块
3. **utils/module_loader.py** - 统一模块加载器
4. **utils/resource_manager.py** - 共享资源管理器
5. **utils/job_manager.py** - 任务管理器
6. **utils/__init__.py** - 更新导出
7. **generation_controller.py** - 使用统一模块加载器，替换print为logger
8. **content_agent.py** - 替换print为logger
9. **matchers/base_matcher.py** - 替换print为logger
10. **matchers/body_matcher.py** - 替换print为logger
11. **matchers/head_matcher.py** - 替换print为logger
12. **app_new.py** - 替换print为logger
