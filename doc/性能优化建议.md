# é¡¹ç›®æ€§èƒ½ä¼˜åŒ–å»ºè®®

> æ›´æ–°æ—¶é—´: 2025-12-26
> çŠ¶æ€: æ ¸å¿ƒä¼˜åŒ–å·²å®Œæˆ

## å®æ–½çŠ¶æ€æ€»è§ˆ

| ä¼˜åŒ–é¡¹ | çŠ¶æ€ | å®æ–½æ–‡ä»¶ |
|--------|------|----------|
| å¯¹è±¡é‡å¤åˆ›å»º | âœ… å·²å®Œæˆ | `utils/resource_manager.py`, `app_new.py` |
| CLIP æ¨¡å‹å•ä¾‹ | âœ… å·²å®Œæˆ | `utils/clip_manager.py`, `matchers/head_matcher.py` |
| API å¹¶è¡Œè°ƒç”¨ | âœ… å·²å®Œæˆ | `generation_controller.py` |
| Gate å¹¶è¡Œæ£€æŸ¥ | âœ… å·²å®Œæˆ | `generation_controller.py` |
| ä»»åŠ¡é˜Ÿåˆ—æ¸…ç† | âœ… å·²å®Œæˆ | `utils/job_manager.py`, `app_new.py` |
| è¿è§„è¯åº“ç¼“å­˜ | ğŸ”„ å¾…ä¼˜åŒ– | `content_agent.py` |
| è¿æ¥æ± ä¼˜åŒ– | ğŸ”„ å¾…ä¼˜åŒ– | å„ API è°ƒç”¨æ¨¡å— |

---

## ä¸€ã€é«˜ä¼˜å…ˆçº§ä¼˜åŒ–ï¼ˆå½±å“å¤§ã€æ”¶ç›Šé«˜ï¼‰

### 1. å¯¹è±¡é‡å¤åˆ›å»ºé—®é¢˜ âœ… å·²å®Œæˆ

**é—®é¢˜ä½ç½®**: `app_new.py` - `_run_generation_job()` å‡½æ•°

**ç°çŠ¶**:
```python
def _run_generation_job(job_id: str, requirement: str):
    # æ¯æ¬¡ä»»åŠ¡éƒ½åˆ›å»ºæ–°å®ä¾‹
    local_head = HeadMatcher()      # é‡å¤åŠ è½½ CLIP æ¨¡å‹
    local_body = BodyMatcher()
    local_agent = ContentAgent()    # é‡å¤åˆå§‹åŒ– API é…ç½®
    local_controller = GenerationController()  # é‡å¤åŠ è½½ 6 ä¸ªæ¨¡å—
    local_processor = ImageProcessor()
```

**é—®é¢˜åˆ†æ**:
- `HeadMatcher` æ¯æ¬¡åˆå§‹åŒ–éƒ½ä¼šæ‡’åŠ è½½ CLIP æ¨¡å‹ï¼ˆçº¦ 500MBï¼‰
- `GenerationController` æ¯æ¬¡åˆå§‹åŒ–éƒ½ä¼šåŠ è½½ 6 ä¸ª Python æ¨¡å—
- `ContentAgent` æ¯æ¬¡åˆå§‹åŒ–éƒ½ä¼šè¯»å–è¿è§„è¯åº“æ–‡ä»¶

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# æ–¹æ¡ˆ1: ä½¿ç”¨å¯¹è±¡æ± 
from utils.resource_manager import SharedResourceManager

def _run_generation_job(job_id: str, requirement: str):
    manager = SharedResourceManager()
    local_head = manager.get_head_matcher()
    local_body = manager.get_body_matcher()
    # ...

# æ–¹æ¡ˆ2: ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„å•ä¾‹
class ThreadSafeHeadMatcher:
    _instance = None
    _lock = threading.Lock()
    
    @classmethod
    def get_instance(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = HeadMatcher()
            return cls._instance
```

**é¢„æœŸæ”¶ç›Š**: å‡å°‘ 50-70% çš„ä»»åŠ¡åˆå§‹åŒ–æ—¶é—´

**å®æ–½ç»“æœ**: 
- åˆ›å»ºäº† `utils/resource_manager.py` å®ç°çº¿ç¨‹å®‰å…¨çš„èµ„æºå…±äº«
- `app_new.py` ä¸­ `_run_generation_job()` å·²ä½¿ç”¨ `resources.get_xxx()` è·å–å…±äº«å®ä¾‹

---

### 2. CLIP æ¨¡å‹åŠ è½½ä¼˜åŒ– âœ… å·²å®Œæˆ

**é—®é¢˜ä½ç½®**: `matchers/head_matcher.py`

**ç°çŠ¶**:
```python
def _ensure_clip_model(self):
    if self.clip_model is None:
        self.clip_model = SentenceTransformer('clip-ViT-B-32')  # æ¯ä¸ªå®ä¾‹ç‹¬ç«‹åŠ è½½
```

**é—®é¢˜åˆ†æ**:
- CLIP æ¨¡å‹çº¦ 500MBï¼ŒåŠ è½½è€—æ—¶ 3-5 ç§’
- æ¯ä¸ª `HeadMatcher` å®ä¾‹éƒ½ä¼šç‹¬ç«‹åŠ è½½
- å¤šçº¿ç¨‹åœºæ™¯ä¸‹å¯èƒ½é‡å¤åŠ è½½å¤šæ¬¡

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# å…¨å±€å•ä¾‹ CLIP æ¨¡å‹
_GLOBAL_CLIP_MODEL = None
_CLIP_LOCK = threading.Lock()

def get_global_clip_model():
    global _GLOBAL_CLIP_MODEL
    with _CLIP_LOCK:
        if _GLOBAL_CLIP_MODEL is None:
            _GLOBAL_CLIP_MODEL = SentenceTransformer('clip-ViT-B-32')
        return _GLOBAL_CLIP_MODEL

class HeadMatcher:
    def _ensure_clip_model(self):
        if self.clip_model is None:
            self.clip_model = get_global_clip_model()
```

**é¢„æœŸæ”¶ç›Š**: é¦–æ¬¡åŠ è½½åï¼Œåç»­ä»»åŠ¡èŠ‚çœ 3-5 ç§’

**å®æ–½ç»“æœ**: 
- åˆ›å»ºäº† `utils/clip_manager.py` å®ç°å…¨å±€ CLIP å•ä¾‹
- `matchers/head_matcher.py` å·²ä½¿ç”¨ `get_clip_model()` å’Œ `get_clip_tokenizer()`

---

### 3. API è°ƒç”¨ä¸²è¡Œç“¶é¢ˆ âœ… å·²å®Œæˆ

**é—®é¢˜ä½ç½®**: `generation_controller.py` - é…é¥°å¤„ç†æµç¨‹

**ç°çŠ¶**:
```python
# ä¸²è¡Œå¤„ç†æ¯å¼ å›¾ç‰‡
for image_path in image_paths:
    result_url = self.banana_clothes.generate_image_with_accessories(image_path, clothes_info)
```

**é—®é¢˜åˆ†æ**:
- æ¯å¼ å›¾ç‰‡çš„é…é¥°å¤„ç†éœ€è¦è°ƒç”¨å¤–éƒ¨ APIï¼ˆçº¦ 10-30 ç§’/å¼ ï¼‰
- å¤šå¼ å›¾ç‰‡ä¸²è¡Œå¤„ç†ï¼Œæ€»è€—æ—¶ = N Ã— å•å¼ è€—æ—¶
- å¤–éƒ¨ API æ”¯æŒå¹¶å‘è°ƒç”¨

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
from concurrent.futures import ThreadPoolExecutor, as_completed

def process_clothes(self, image_paths: List[str], clothes_info: str) -> List[str]:
    if not clothes_info:
        return image_paths
    
    processed_images = []
    max_workers = min(4, len(image_paths))  # é™åˆ¶å¹¶å‘æ•°
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {
            executor.submit(
                self.banana_clothes.generate_image_with_accessories,
                img_path, clothes_info
            ): img_path for img_path in image_paths
        }
        
        for future in as_completed(futures):
            original_path = futures[future]
            try:
                result = future.result(timeout=120)
                processed_images.append(result if result else original_path)
            except Exception:
                processed_images.append(original_path)
    
    return processed_images
```

**é¢„æœŸæ”¶ç›Š**: 4 å¼ å›¾ç‰‡å¹¶è¡Œå¤„ç†ï¼Œæ€»è€—æ—¶ä» 120 ç§’é™è‡³ 30-40 ç§’

**å®æ–½ç»“æœ**: 
- `generation_controller.py` ä¸­æ·»åŠ äº† `_process_accessory_parallel()` é€šç”¨å¹¶è¡Œå¤„ç†æ–¹æ³•
- `process_clothes()`, `process_hands()`, `process_hats()` å‡å·²ä½¿ç”¨å¹¶è¡Œå¤„ç†
- é€šè¿‡ `MAX_PARALLEL_WORKERS` ç¯å¢ƒå˜é‡æ§åˆ¶å¹¶å‘æ•°ï¼ˆé»˜è®¤ 3ï¼‰

---

### 4. Gate æ£€æŸ¥æ€§èƒ½ä¼˜åŒ– âœ… å·²å®Œæˆ

**é—®é¢˜ä½ç½®**: `gate-result.py`

**ç°çŠ¶**:
```python
def analyze_image_with_three_models(image_path: str):
    # ä¸²è¡Œè°ƒç”¨å¤šä¸ªæ¨¡å‹
    res_flash = run_gemini_flash_generation(image_path, PROMPT_FLASH)
    # res_gemini_chat = call_analysis_api(...)  # å·²æ³¨é‡Š
    # res_claude = call_analysis_api(...)       # å·²æ³¨é‡Š
```

**é—®é¢˜åˆ†æ**:
- å½“å‰åªä½¿ç”¨ 1 ä¸ªæ¨¡å‹ï¼Œä½†ä»£ç ç»“æ„æ”¯æŒ 3 ä¸ª
- æ¯å¼ å›¾ç‰‡çš„ Gate æ£€æŸ¥çº¦ 5-10 ç§’
- æœ€ç»ˆ Gate æ£€æŸ¥å¯¹æ‰€æœ‰å›¾ç‰‡ä¸²è¡Œæ‰§è¡Œ

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# 1. å¹¶è¡Œæ£€æŸ¥å¤šå¼ å›¾ç‰‡
def final_gate_check(self, image_paths: List[str]) -> List[str]:
    with ThreadPoolExecutor(max_workers=3) as executor:
        results = list(executor.map(
            lambda p: (p, self.gate_check.analyze_image_with_three_models(p)),
            image_paths
        ))
    return [p for p, (ok, _) in results if ok]

# 2. æ·»åŠ ç»“æœç¼“å­˜ï¼ˆç›¸åŒå›¾ç‰‡ä¸é‡å¤æ£€æŸ¥ï¼‰
_gate_cache = {}

def analyze_with_cache(image_path: str):
    cache_key = hashlib.md5(open(image_path, 'rb').read()).hexdigest()
    if cache_key in _gate_cache:
        return _gate_cache[cache_key]
    result = analyze_image_with_three_models(image_path)
    _gate_cache[cache_key] = result
    return result
```

**é¢„æœŸæ”¶ç›Š**: å¤šå›¾å¹¶è¡Œæ£€æŸ¥ï¼Œæ€»è€—æ—¶å‡å°‘ 60-70%

**å®æ–½ç»“æœ**: 
- `final_gate_check()` å·²æ”¯æŒå¹¶è¡Œæ£€æŸ¥
- å•å¼ å›¾ç‰‡ç›´æ¥æ£€æŸ¥ï¼Œå¤šå¼ å›¾ç‰‡ä½¿ç”¨ `ThreadPoolExecutor` å¹¶è¡Œ
- æ·»åŠ äº† `_gate_check_parallel()` å’Œ `_check_single_image_gate()` è¾…åŠ©æ–¹æ³•

---

## äºŒã€ä¸­ä¼˜å…ˆçº§ä¼˜åŒ–ï¼ˆå½±å“ä¸­ç­‰ï¼‰

### 5. ä»»åŠ¡é˜Ÿåˆ—å†…å­˜æ³„æ¼é£é™© âœ… å·²å®Œæˆ

**é—®é¢˜ä½ç½®**: `app_new.py`

**ç°çŠ¶**:
```python
jobs = {}  # å…¨å±€å­—å…¸ï¼Œæ— æ¸…ç†æœºåˆ¶
jobs_lock = threading.Lock()
```

**é—®é¢˜åˆ†æ**:
- å·²å®Œæˆçš„ä»»åŠ¡æ°¸ä¹…ä¿ç•™åœ¨å†…å­˜ä¸­
- é•¿æ—¶é—´è¿è¡Œåå†…å­˜æŒç»­å¢é•¿
- æ—  TTL è¿‡æœŸæœºåˆ¶

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# ä½¿ç”¨å·²åˆ›å»ºçš„ JobManager
from utils.job_manager import JobManager

job_manager = JobManager(ttl_seconds=3600, cleanup_interval=300)

# æ›¿æ¢åŸæœ‰çš„ jobs å­—å…¸æ“ä½œ
def _init_job(requirement: str) -> str:
    return job_manager.create_job(requirement)

def _update_job(job_id: str, **fields):
    job_manager.update_job(job_id, **fields)
```

**é¢„æœŸæ”¶ç›Š**: é˜²æ­¢å†…å­˜æ³„æ¼ï¼Œä¿æŒç¨³å®šå†…å­˜å ç”¨

**å®æ–½ç»“æœ**: 
- åˆ›å»ºäº† `utils/job_manager.py` å®ç°å¸¦ TTL çš„ä»»åŠ¡ç®¡ç†
- `app_new.py` å·²ä½¿ç”¨ `job_manager` æ›¿ä»£åŸæœ‰çš„ `jobs` å­—å…¸
- é»˜è®¤ TTL 3600 ç§’ï¼Œæ¸…ç†é—´éš” 300 ç§’

---

### 6. è¿è§„è¯åº“åŠ è½½ä¼˜åŒ– ğŸ”„ å¾…ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: `content_agent.py`

**ç°çŠ¶**:
```python
def __init__(self):
    self.banned_words, self.banned_patterns = self._load_external_banned_words()
```

**é—®é¢˜åˆ†æ**:
- æ¯æ¬¡åˆ›å»º `ContentAgent` éƒ½è¯»å–æ–‡ä»¶
- æ­£åˆ™è¡¨è¾¾å¼æ¯æ¬¡éƒ½é‡æ–°ç¼–è¯‘

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼å¹¶ç¼“å­˜
_BANNED_WORDS_CACHE = None
_BANNED_PATTERNS_CACHE = None

def _load_external_banned_words(self):
    global _BANNED_WORDS_CACHE, _BANNED_PATTERNS_CACHE
    
    if _BANNED_WORDS_CACHE is not None:
        return _BANNED_WORDS_CACHE, _BANNED_PATTERNS_CACHE
    
    banned_words = []
    banned_patterns = []
    # ... åŠ è½½é€»è¾‘ ...
    
    # é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
    compiled_patterns = [re.compile(p, re.IGNORECASE) for p in banned_patterns]
    
    _BANNED_WORDS_CACHE = banned_words
    _BANNED_PATTERNS_CACHE = compiled_patterns
    return banned_words, compiled_patterns
```

**é¢„æœŸæ”¶ç›Š**: å‡å°‘æ–‡ä»¶ I/O å’Œæ­£åˆ™ç¼–è¯‘å¼€é”€

---

### 7. å›¾ç‰‡å¤„ç† I/O ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: `image_processor.py`, `per-data.py`

**ç°çŠ¶**:
- å›¾ç‰‡å¤šæ¬¡è¯»å–å’Œä¿å­˜
- æœªä½¿ç”¨å†…å­˜ç¼“å†²

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# ä½¿ç”¨ BytesIO å‡å°‘ç£ç›˜ I/O
from io import BytesIO

def process_image_in_memory(image_path: str) -> BytesIO:
    with Image.open(image_path) as img:
        buffer = BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        return buffer

# æ‰¹é‡å¤„ç†æ—¶å¤ç”¨å›¾ç‰‡æ•°æ®
def batch_process(image_paths: List[str]):
    image_cache = {}
    for path in image_paths:
        if path not in image_cache:
            image_cache[path] = Image.open(path)
        # ä½¿ç”¨ç¼“å­˜çš„å›¾ç‰‡å¯¹è±¡
```

---

## ä¸‰ã€ä½ä¼˜å…ˆçº§ä¼˜åŒ–ï¼ˆé•¿æœŸæ”¹è¿›ï¼‰

### 8. æ—¥å¿—æ€§èƒ½ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: å¤šä¸ªæ–‡ä»¶

**ç°çŠ¶**:
```python
logger.info(f"å¤„ç†å›¾ç‰‡: {image_path}")  # å­—ç¬¦ä¸²æ ¼å¼åŒ–æ€»æ˜¯æ‰§è¡Œ
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# ä½¿ç”¨å»¶è¿Ÿæ ¼å¼åŒ–
logger.info("å¤„ç†å›¾ç‰‡: %s", image_path)

# æˆ–æ£€æŸ¥æ—¥å¿—çº§åˆ«
if logger.isEnabledFor(logging.DEBUG):
    logger.debug(f"è¯¦ç»†ä¿¡æ¯: {expensive_operation()}")
```

---

### 9. é…ç½®çƒ­åŠ è½½

**é—®é¢˜ä½ç½®**: `config.py`

**ç°çŠ¶**:
- é…ç½®åœ¨å¯åŠ¨æ—¶åŠ è½½ä¸€æ¬¡
- ä¿®æ”¹é…ç½®éœ€è¦é‡å¯æœåŠ¡

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
class Config:
    _last_load_time = 0
    _cache_ttl = 60  # 60ç§’ç¼“å­˜
    
    @classmethod
    def get_config(cls):
        if time.time() - cls._last_load_time > cls._cache_ttl:
            cls._reload_config()
        return cls._instance
```

---

### 10. è¿æ¥æ± ä¼˜åŒ–

**é—®é¢˜ä½ç½®**: æ‰€æœ‰ API è°ƒç”¨æ¨¡å—

**ç°çŠ¶**:
```python
response = requests.post(api_url, ...)  # æ¯æ¬¡åˆ›å»ºæ–°è¿æ¥
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# ä½¿ç”¨ Session å¤ç”¨è¿æ¥
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
retry = Retry(total=3, backoff_factor=0.5)
adapter = HTTPAdapter(max_retries=retry, pool_connections=10, pool_maxsize=20)
session.mount('https://', adapter)

# ä½¿ç”¨ session å‘é€è¯·æ±‚
response = session.post(api_url, ...)
```

**é¢„æœŸæ”¶ç›Š**: å‡å°‘ TCP æ¡æ‰‹å¼€é”€ï¼Œæå‡ API è°ƒç”¨é€Ÿåº¦ 10-20%

---

## å››ã€ä¼˜åŒ–å®æ–½ä¼˜å…ˆçº§

| ä¼˜å…ˆçº§ | ä¼˜åŒ–é¡¹ | é¢„æœŸæ”¶ç›Š | å®æ–½éš¾åº¦ | å»ºè®®æ—¶é—´ |
|--------|--------|----------|----------|----------|
| P0 | å¯¹è±¡é‡å¤åˆ›å»º | 50-70% åˆå§‹åŒ–æ—¶é—´ | ä¸­ | 1-2å¤© |
| P0 | CLIP æ¨¡å‹å•ä¾‹ | 3-5ç§’/ä»»åŠ¡ | ä½ | 0.5å¤© |
| P1 | API å¹¶è¡Œè°ƒç”¨ | 60-70% é…é¥°å¤„ç†æ—¶é—´ | ä¸­ | 1å¤© |
| P1 | Gate å¹¶è¡Œæ£€æŸ¥ | 60-70% æ£€æŸ¥æ—¶é—´ | ä¸­ | 1å¤© |
| P2 | ä»»åŠ¡é˜Ÿåˆ—æ¸…ç† | é˜²æ­¢å†…å­˜æ³„æ¼ | ä½ | 0.5å¤© |
| P2 | è¿è§„è¯åº“ç¼“å­˜ | å‡å°‘ I/O | ä½ | 0.5å¤© |
| P3 | è¿æ¥æ± ä¼˜åŒ– | 10-20% API é€Ÿåº¦ | ä½ | 0.5å¤© |

---

## äº”ã€æ€§èƒ½ç›‘æ§å»ºè®®

### æ·»åŠ æ€§èƒ½æŒ‡æ ‡æ”¶é›†
```python
import time
from functools import wraps

def timing_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        logger.info(f"{func.__name__} è€—æ—¶: {elapsed:.2f}ç§’")
        return result
    return wrapper

# åº”ç”¨åˆ°å…³é”®å‡½æ•°
@timing_decorator
def process_clothes(self, image_paths, clothes_info):
    ...
```

### å…³é”®æŒ‡æ ‡
- ä»»åŠ¡æ€»è€—æ—¶
- å„é˜¶æ®µè€—æ—¶ï¼ˆåˆ†æã€åŒ¹é…ã€ç»„åˆã€é…é¥°ã€Gateæ£€æŸ¥ï¼‰
- API è°ƒç”¨æˆåŠŸç‡å’Œå“åº”æ—¶é—´
- å†…å­˜ä½¿ç”¨é‡
- å¹¶å‘ä»»åŠ¡æ•°
