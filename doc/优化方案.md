# Joy IP 3D 项目优化方案

## 一、代码重复问题优化

### 1.1 问题描述

`app_new.py` 中 `_sanitize` 函数被重复定义了3次：
- `_run_generation_job` 函数内（约第200行）
- `/api/generate` 路由内（约第480行）
- `/api/analyze` 路由内（约第1280行）

### 1.2 优化方案

**方案：将 `_sanitize` 提取为模块级函数，与已有的 `is_valid_accessory` 合并**

#### 修改前（重复代码示例）：

```python
# 在 _run_generation_job 中
def _sanitize(val: str, label: str) -> str:
    if not isinstance(val, str):
        return ''
    v = val.strip()
    # ... 重复逻辑
```

#### 修改后：

在 `app_new.py` 文件顶部（约第100行后）添加统一的工具函数：

```python
# =========================
# 通用工具函数
# =========================

def sanitize_accessory_value(val: str, label: str) -> str:
    """
    规范化配饰字段值，过滤无效/误填内容
    
    Args:
        val: 原始值
        label: 字段标签（服装/手拿/头戴/背景）
    
    Returns:
        str: 清洗后的值，无效时返回空字符串
    """
    if not isinstance(val, str):
        return ''
    v = val.strip()
    if not v:
        return ''
    
    # 否定词处理（背景保留"无"）
    none_words = {"无", "没有", "未提供", "不带", "不戴", "不拿"}
    if v in none_words:
        return '无' if label == '背景' else ''
    
    # 检查是否以其他标签开头（误填）
    for other in ['服装', '手拿', '头戴', '背景']:
        if other != label and re.match(rf"^{other}[：:]", v):
            return ''
    
    # 交叉关键词检查
    if label == '手拿' and '头戴' in v:
        return ''
    if label == '头戴' and '手拿' in v:
        return ''
    
    return v


def sanitize_analysis_result(analysis: Dict[str, str]) -> Dict[str, str]:
    """
    批量清洗分析结果中的配饰字段
    
    Args:
        analysis: 原始分析结果字典
    
    Returns:
        Dict: 清洗后的分析结果
    """
    for key in ['服装', '手拿', '头戴', '背景']:
        if key in analysis:
            analysis[key] = sanitize_accessory_value(analysis.get(key, ''), key)
    
    # 常见错位模式强制纠正
    if isinstance(analysis.get('服装'), str) and analysis['服装'].startswith('手拿'):
        analysis['服装'] = ''
    if isinstance(analysis.get('手拿'), str) and analysis['手拿'].startswith('头戴'):
        analysis['手拿'] = ''
    if isinstance(analysis.get('头戴'), str) and analysis['头戴'].startswith('背景'):
        analysis['头戴'] = ''
    
    return analysis
```

#### 使用方式：

```python
# 在 _run_generation_job 中
analysis = agent_result['analysis']
analysis = sanitize_analysis_result(analysis)  # 一行代码替代重复定义

# 在 /api/generate 中
analysis = agent_result['analysis']
analysis = sanitize_analysis_result(analysis)

# 在 /api/analyze 中
result['analysis'] = sanitize_analysis_result(result.get('analysis', {}))
```

### 1.3 同时优化 `is_valid_accessory` 函数

现有的 `is_valid_accessory` 函数可以复用 `sanitize_accessory_value`：

```python
def is_valid_accessory(label: str, val: str) -> bool:
    """判断配饰值是否有效"""
    return bool(sanitize_accessory_value(val, label))
```

---

## 二、配置管理问题优化

### 2.1 问题描述

API密钥硬编码在多个文件中：
- `config.py`: `AI_API_KEY = 'pk-a3b4d157-e765-45b9-988a-b8b2a6d7c8bf'`
- `content_agent.py`: `self.api_token = "pk-a3b4d157-e765-45b9-988a-b8b2a6d7c8bf"`
- `matchers/base_matcher.py`: `self.api_token = "pk-a3b4d157-e765-45b9-988a-b8b2a6d7c8bf"`

### 2.2 优化方案

**方案：统一配置管理，所有敏感信息从环境变量或配置文件读取**

#### 步骤1：更新 `config.py`

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
配置文件 - 统一配置管理
"""

import os
from typing import Optional


class Config:
    """应用配置类"""
    
    # =========================
    # AI API 配置（统一管理）
    # =========================
    AI_API_URL: str = os.environ.get(
        'AI_API_URL', 
        'https://modelservice.jdcloud.com/v1/chat/completions'
    )
    AI_API_KEY: str = os.environ.get(
        'AI_API_KEY', 
        ''  # 生产环境必须通过环境变量设置
    )
    AI_MODEL: str = os.environ.get('AI_MODEL', 'Gemini-2.5-pro')
    
    # =========================
    # Flask 配置
    # =========================
    DEBUG: bool = os.environ.get('DEBUG', 'false').lower() == 'true'
    SECRET_KEY: str = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')
    HOST: str = os.environ.get('HOST', '0.0.0.0')
    PORT: int = int(os.environ.get('PORT', 28888))
    
    # =========================
    # 文件路径配置
    # =========================
    OUTPUT_DIR: str = os.environ.get('OUTPUT_DIR', 'output')
    GENERATED_IMAGES_DIR: str = os.environ.get('GENERATED_IMAGES_DIR', 'generated_images')
    DATA_DIR: str = os.environ.get('DATA_DIR', 'data')
    
    # =========================
    # 单端口模式配置
    # =========================
    SINGLE_PORT_MODE: bool = os.environ.get('SINGLE_PORT_MODE', 'true').lower() == 'true'
    FRONTEND_BUILD_DIR: str = os.environ.get('FRONTEND_BUILD_DIR', 'frontend_dist')
    
    # =========================
    # CORS 配置
    # =========================
    CORS_ENABLED: bool = os.environ.get('CORS_ENABLED', 'false').lower() == 'true'
    CORS_ORIGINS: list = os.environ.get('CORS_ORIGINS', '*').split(',')
    
    # =========================
    # 脚本执行配置
    # =========================
    SCRIPT_TIMEOUT: int = int(os.environ.get('SCRIPT_TIMEOUT', 120))
    
    # =========================
    # 图片生成配置
    # =========================
    MAX_RETRIES: int = int(os.environ.get('MAX_RETRIES', 3))
    IMAGE_QUALITY_CHECK: bool = os.environ.get('IMAGE_QUALITY_CHECK', 'true').lower() == 'true'
    
    @classmethod
    def validate(cls) -> bool:
        """验证必要配置是否已设置"""
        errors = []
        
        if not cls.AI_API_KEY:
            errors.append("AI_API_KEY 未设置")
        
        if errors:
            print("配置验证失败:")
            for err in errors:
                print(f"  - {err}")
            return False
        
        return True


# 单例配置对象
_config: Optional[Config] = None


def get_config() -> Config:
    """获取配置单例"""
    global _config
    if _config is None:
        _config = Config()
    return _config
```

#### 步骤2：更新 `.env` 文件

```env
# AI API 配置
AI_API_URL=https://modelservice.jdcloud.com/v1/chat/completions
AI_API_KEY=pk-a3b4d157-e765-45b9-988a-b8b2a6d7c8bf
AI_MODEL=Gemini-2.5-pro

# Flask 配置
DEBUG=false
SECRET_KEY=your-production-secret-key
HOST=0.0.0.0
PORT=28888

# 文件路径
OUTPUT_DIR=output
GENERATED_IMAGES_DIR=generated_images

# 单端口模式
SINGLE_PORT_MODE=true
FRONTEND_BUILD_DIR=frontend_dist
```

#### 步骤3：更新 `content_agent.py`

```python
from config import get_config

class ContentAgent:
    def __init__(self):
        config = get_config()
        self.api_url = config.AI_API_URL
        self.api_token = config.AI_API_KEY
        self.model = config.AI_MODEL
        # ... 其他初始化代码
```

#### 步骤4：更新 `matchers/base_matcher.py`

```python
import sys
import os

# 确保能导入项目根目录的 config
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config import get_config


class BaseMatcher:
    def __init__(self):
        config = get_config()
        self.api_url = config.AI_API_URL
        self.api_token = config.AI_API_KEY
        self.model = config.AI_MODEL
        # ... 其他初始化代码
```

#### 步骤5：更新 `.gitignore`

确保 `.env` 文件不被提交到版本控制：

```gitignore
# 环境配置文件（包含敏感信息）
.env
.env.local
.env.production

# 保留示例文件
!.env.example
!.env.local.example
```

### 2.3 配置加载流程

```
应用启动
    ↓
加载 .env 文件（python-dotenv）
    ↓
Config 类从 os.environ 读取配置
    ↓
get_config() 返回配置单例
    ↓
各模块通过 get_config() 获取配置
```

### 2.4 可选：添加 python-dotenv 支持

在 `requirements.txt` 中添加：

```
python-dotenv==1.0.0
```

在 `app_new.py` 启动时加载：

```python
from dotenv import load_dotenv
load_dotenv()  # 在导入 config 之前调用
```

---

## 三、实施优先级

| 优先级 | 优化项 | 工作量 | 影响范围 |
|--------|--------|--------|----------|
| P0 | 配置管理（移除硬编码密钥） | 2小时 | 安全性 |
| P1 | 代码重复（提取公共函数） | 1小时 | 可维护性 |
| P2 | 添加配置验证 | 30分钟 | 稳定性 |

---

## 四、验证清单

- [x] 所有 API 密钥从环境变量读取
- [x] `.env` 文件已添加到 `.gitignore`
- [x] `_sanitize` 函数只定义一次（已提取为 `sanitize_accessory_value` 和 `sanitize_analysis_result`）
- [x] 所有模块使用 `get_config()` 获取配置
- [x] 应用启动时验证必要配置（`Config.validate()` 方法）

## 五、已完成的修改

1. **config.py** - 重构为统一配置管理，支持环境变量和 .env 文件
2. **content_agent.py** - 使用 `get_config()` 获取 API 配置
3. **matchers/base_matcher.py** - 使用 `get_config()` 获取 API 配置
4. **.env** - 更新为完整的配置模板
5. **app_new.py** - 添加 `sanitize_accessory_value` 和 `sanitize_analysis_result` 函数，移除3处重复的 `_sanitize` 定义
